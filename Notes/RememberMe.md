# Safety Tips

## Ubuntu specifies that `gcc` specify non-lazy binding

Despite the fact that the `man` page for `ld` says that *lazy binding* is the default, Ubuntu builds `gcc` in such a way that it does *non-lazy binding* (`now`)by default. 

To override this behavior, specify `-z lazy` to `gcc` when you are compiling.

In addition, it also specifies `relro` which marks the memory holding the relocation section (at runtime) as read only (once the initial relocations are complete). Obviously you cannot have `relro` without `now`. This technique prevents malicious code from hijacking the process by updating the relocations at runtime.

## Relocations

All dynamically loaded functions have relocations! However, the compiler will generate code for calls to *most* of those dynamic functions that goes through the PLT. The calls *from the PLT*, however, target the relocations. 

For the rest of this note, I will use `printf` as an example, but the lesson is the same for many other functions.

Most importantly, `printf@plt` is not the same as `printf@GLIBC`. Code generated by the compiler for a program's call to `printf` *usually* go through `printf@PLT`. In lazy loading mode, the first time that `printf@GLIBC` is invoked, its relocation points to the loader whose job it is to load that function into memory and update the relocation appropriately. For non-lazy loading, the first time that `printf@GLIBC` is invoked, it points to the location of that function in memory (because the non-lazy loading forced the loading of that function at program startup). 

These semantics are confusing if you are comparing how the program starts and invokes `__libc_main_start@GLIBC` versus how user code invokes `printf@plt` (which, in turn, invokes `printf@GLIBC`).


