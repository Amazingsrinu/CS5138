// Totally copied (and then modified) from
// https://github.com/yadutaf/tracepkt/blob/master/tracepkt.c

#include <bcc/proto.h>
#include <linux/skbuff.h>
#include <net/icmp.h>
#include <net/protocol.h>
#include <uapi/linux/icmp.h>
#include <uapi/linux/icmpv6.h>
#include <uapi/linux/ip.h>
#include <uapi/linux/ipv6.h>
#
struct connect_evt {
  int pid;
  u64 ip_version; // familiy (IPv4 or IPv6)
  uint64_t daddr[2];
};
BPF_PERF_OUTPUT(tcp_connect_event);

static inline int do_sys_enter_connect(void *ctx, int pid,
                                       struct sockaddr *pdaddr) {
  struct connect_evt evt = {};
  struct sockaddr daddr;

  evt.pid = pid;

  if (bpf_probe_read_user(&daddr, sizeof(struct sockaddr), (void *)pdaddr)) {
    return 0;
  }

  if (daddr.sa_family == AF_INET) {
    struct sockaddr_in *daddr_in = (struct sockaddr_in *)&daddr;
    memcpy(&evt.daddr, &daddr_in->sin_addr, sizeof(struct in_addr));
    evt.ip_version = 4;
  } else if (daddr.sa_family == AF_INET6) {
    struct sockaddr_in6 *daddr_in6 = (struct sockaddr_in6 *)&daddr;
    memcpy(&evt.daddr, &daddr_in6->sin6_addr, sizeof(struct in6_addr));
    evt.ip_version = 6;
  } else {
    return 0;
  }

  tcp_connect_event.perf_submit(ctx, &evt, sizeof(struct connect_evt));

  return 0;
}

TRACEPOINT_PROBE(syscalls, sys_enter_connect) {
  int pid = bpf_get_current_pid_tgid();
  return do_sys_enter_connect(args, pid, (struct sockaddr *)args->uservaddr);
}
